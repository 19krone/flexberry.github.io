---
title: Ключевые понятия объектной структуры для прикладных систем, разрабатывающихся в Flexberry Designer
sidebar: flexberry-designer_sidebar
keywords: Flexberry Designer, Flexberry ORM, Public, Ключевые понятия
toc: true
permalink: ru/fd_key-concepts-flexberry-designer.html
folder: products/flexberry-designer/
lang: ru
---

<div style="margin:5px; padding-left:28px; float:right; width:40%; outline:1px solid white;">
<br>
<table border="0" width="100%" bgcolor="#6495ED">
<tbody><tr><td bgcolor="#FFFFFF">
* '''Продукт''': [Flexberry Designer](flexberry-designer.html)
* '''Предназначение''': Проектирование информационных систем.
</td>
</tr></tbody></table></a>
</div>

# Ключевые понятия
Структура данных определяет структуру приложения. В основу систем кладётся структура данных, выражаемая диаграммой классов UML.


Рассмотрим на примере диаграммы классов основные понятия на основе элементарных понятий `UML` (не рассматриваются понятия атрибута, метода, параметра метода, типа, роли ассоциации и т.п., поскольку они очевидны и целиком заимствуются из `UML`). Данная [диаграмма классов](class-diagram.html) также иллюстрирует типовые ситуации, возникающие при проектировании. Любые другие ситуации — следствия из данной диаграммы.


![](/images/pages/img/«Аксиомы» Flexberry/пример1.jpg)
Класс, относительно которого в конкретной ситуации рассматриваются ассоциации, называется '''внутренним классом''', а остальные — '''внешними'''.

'''Вложением (подобъектом)''' называется атрибут класса, чей тип — другой класс.

## Мастеровые ассоциации
Ассоциации, подобные ассоциации между `Internal` и `Master1` называются '''[мастеровыми](master--association.html)''', а внешний класс со стороны множественности 1, либо 0..1 называется '''мастеровым''' или '''мастером'''. 

[Мастеровая ассоциация](master--association.html) может быть проведена между классами, каждый из которых является детейлом, а шапка у них общая. Пример этому — ассоциация `Detail2-Detail3`.

## Детейловые композиции, агрегатор, шапка
Ассоциации агрегации или агрегации-композиции, подобные `Internal-Detail1` называются '''[детейловыми](detail-associations-and-their-properties.html)''', а внешний класс — '''детейловым''', либо просто '''детейлом'''. Внутренний класс по отношению к детейлу также называют '''агрегатором или шапкой'''.

## Наследование
Ассоциации наследования, подобные `Internal-InternalChild` называются `[наследованием](inheritance.html)`, внутренний класс в такой ассоциации — `предок`, а внешний — `потомок`. 


''При наследовании атрибутный состав и состав связей всегда расширяется и не может сокращаться.''

Наследнику доступны все атрибуты и ассоциации предка. Так, если взять за внутренний класс `InternalChild`, то его атрибуты будут `Attr1` и `Attr2`, мастера `Master1`, `Master2`, `Master3`, детейлы `Detail1, Detail2, Detail3, Detail4`.

Предок обеспечивает полиморфный доступ ко всем своим наследникам, что означает, что экземпляру внутреннего класса и его наследникам (в данном случае — `Internal и InternalChild`) может быть установлен как экземпляр мастерового класса (в данном случае `Master2`), так и экземпляр любого наследника мастера (в данном случае `Master2Child`). Аналогична ситуация и с детейлами: экземпляр `Internal` одинаково, через `Detail2` оперирует с экземплярами `Detail2 и Detail2Child`, аналогично и для атрибутов и методов класса.

Если у наследника есть атрибут, метод (с тем же составом параметров), ассоциация (с тем же именем роли), то это значит, что наследник '''перегружает''' данный элемент предка.

Наследник от мастера может являться детейлом того же внутреннего класса (как в ситуации `Internal-Master1-Detail4`), это нормально.

[Flexberry ORM](flexberry-o-r-m.html), полностью реализует объектно-ориентированную концепцию, поскольку кроме инкапсуляции и полиморфизма даёт возможность полноценно использовать наследование при объектно-реляционном отображении.

## Стереотипы
Классам на диаграмме классов приписываются стереотипы, позволяющие указать назначение того или иного `UML`-класса.


В `Flexberry Designer` предопределены следующие стереотипы:


# ''[Implementation](data--classes.html)'', стереотип по-умолчанию (на диаграммах указывается пустым значением), обычный `UML`-класс, реализуемый в исходный код классами объектов данных. Классы могут связываться любыми ассоциациями;
# ''[TypeDef](classes-with-stereotype--typedef.html)'', стереотип, указывающий синоним типа. При генерации кода синонимы приводятся к базовым типам целевого языка с помощью пользователя (в код попадает базовый тип, а синоним не указывается никак). На диаграммах не может быть связан никакими ассоциациями;
# ''[Типы-данных-классы-со-стереотипом-type-и-их-своиства|Type]'', стереотип, вводящий новый тип. При генерации кода на целевом языке объявляется этот тип, и при объявлениях членов классов, параметров и т.п. используется он. 
# ''[Enumeration](enumerations.html)'', стереотип, вводящий перечислимый тип. На диаграммах не может быть связан никакими ассоциациями;
# ''[Interface](interfaces.html)'', стереотип, вводящий `.Net`-интерфейс. Интерфейсы могут связываться любыми ассоциациями;
# ''[BusinessServer](business-servers.html)'', стереотип, соответствующий бизнес-серверу — `.Net` классу, где расположена реализация бизнес-операций прикладной системы;
# ''[EditForm](fd_classes-with-stereotype-editform.html)'', стереотип, соответствующий форме редактирования — `.Net` классу, где расположена реализация формы для редактирования объекта данных;
# ''[ListForm](Формы-списка-классы-со-стереотипом-listform.html)'', стереотип, соответствующий форме списка — `.Net` классу, где расположена реализация формы для отображения списка объектов данных;
# ''PrintForm'', стереотип, соответствующий форме печати — .Net классу, где расположена реализация формы для печати;
# ''UserForm'', стереотип, соответствующий пустой форме;
# ''[EventArg](classes-with-stereotype-eventarg.html)'', стереотип, соответствующий параметрам события (event), при генерации полученный класс наследуется от `System.EventArgs`;
# ''[Application](application.html)'', стереотип, соответствующий приложению: форме рабочего стола и настроечному классу;
# ''Role'', стереотип, соответствующий роли в системе полномочий;
# ''[External](external-classes.html)'', стереотип, соответствующий любому внешнему (не объявленному в `CASE`, языковому) классу.
# ''[ExternalInterface](external-interface.html)'', стереотип, соответствующий любому внешнему (не объявленному в `CASE`) интерфейсу.
# Пользователь может указать произвольный стереотип.


## Неочевидные ограничения объектной структуры (как не надо делать)
Нотация `UML` описывает назначение своих элементов, однако никак не декларирует «правильность» их использования.



Поэтому, рассмотрим основные неочевидные ограничения, которые не описываются нотацией, вызывают затруднения при понимании, невозможны при реализации, __которых следует избегать__.


### Циклические детейлы
Детейл любого уровня не может являться наследником шапки, поскольку в таком случае получается что объект наследника должен включать сам себя.
![](/images/pages/img/«Аксиомы» Flexberry/пример2.jpg)
### Противоречивая агрегация
Наследник от детейла не может являться детейлом наследника шапки.
![](/images/pages/img/«Аксиомы» Flexberry/пример3.jpg)

### Однако
Вот такая ситуация возможна:
![](/images/pages/img/«Аксиомы» Flexberry/LookUpAsMaster.PNG)
