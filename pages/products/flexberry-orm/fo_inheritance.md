---
title: Наследование 
sidebar: flexberry-orm_sidebar
keywords: Flexberry ORM, Public, Ключевые понятия
toc: true
permalink: ru/fo_inheritance.html
folder: products/flexberry-orm/
lang: ru
---

## Определение  наследования

Ассоциации наследования, подобные `Internal-InternalChild` называются `наследованием`, внутренний класс в такой ассоциации — `предок`, а внешний — `потомок`. 


![](/img/«Аксиомы» CASEBERRY/пример1.jpg)

## Основные свойства наследования

* При наследовании атрибутный состав и состав связей всегда расширяется и не может сокращаться (при этом каждая унаследованная таблица [DataObjectsAndDatabaseStructures|хранит `все` атрибуты `всех` предков)).
* Наследнику доступны все атрибуты и ассоциации предка. Так, если взять за внутренний класс `InternalChild`, то его атрибуты будут `Attr1` и `Attr2`, мастера `Master1`, `Master2`, `Master3`, детейлы `Detail1, Detail2, Detail3, Detail4`.
* Предок обеспечивает полиморфный доступ ко всем своим наследникам, что означает, что экземпляру внутреннего класса и его наследникам (в данном случае — `Internal и InternalChild`) может быть установлен как экземпляр мастерового класса (в данном случае `Master2`), так и экземпляр любого наследника мастера (в данном случае `Master2Child`). Аналогична ситуация и с детейлами: экземпляр `Internal` одинаково, через `Detail2` оперирует с экземплярами `Detail2 и Detail2Child`, аналогично и для атрибутов и методов класса. На практике данное явление может вызвать [TypeUsage-problem|проблему, решаемую с помощью TypeUsage), которое [TypeUsage-in-data-structure|особым образом отображается в структуру данных).
* Если у наследника есть атрибут, метод (с тем же составом параметров), ассоциация (с тем же именем роли), то это значит, что наследник `перегружает` данный элемент предка.
* Наследник от мастера может являться детейлом того же внутреннего класса (как в ситуации `Internal-Master1-Detail4`), это нормально.

<msg type=note>Часто задаётся вопрос, почему таблицы [Inheritance|наследников) хранят все атрибуты всех предков, а не только свои. Ответ: тогда при чтении [Inheritance|объекта-наследника) необходимо собирать все атрибуты от таблиц предков по цепочке через `JOIN`, что очень медленно, особенно при чтении разнотипных объектов одним запросом. Следовательно, производительность приложения будет падать с ростом числа уровней [Inheritance|наследования), что неприемлемо.</msg>
