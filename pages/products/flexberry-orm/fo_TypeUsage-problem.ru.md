---
title: Проблема используемых типов (TypeUsage)
sidebar: flexberry-orm_sidebar
keywords: DataObject (объекты данных), Flexberry ORM, Public
toc: true
permalink: ru/fo_type-usage-problem.html
folder: products/flexberry-orm/
lang: ru
---

<div style="margin:5px; padding-left:28px; float:right; width:40%; outline:1px solid white;"> <br> <table border="0" width="100%" bgcolor="#6495ED"> <tbody><tr><td bgcolor="#FFFFFF"> 

* '''Продукт''': [Flexberry ORM](fo_flexberry-orm.html)
* '''Компонент''': [Объект данных](fo_dataobject.html)
* '''Программная библиотека''': ICSSoft.STORMNET.DataObject.dll
* '''Предназначение''': Описаны проблемы, возникающие, когда у [мастера](master--association.html) есть [наследники](inheritance.html), и как с ними можно бороться.
</td>
</tr></tbody></table></a>
</div>

# Проблема используемых типов
При использовании [наследования](inheritance.html)  возникает проблема определения нужного типа при использовании ассоциации. Другими словами, если [мастером](master--association.html) типа является тип, связанный [наследованием](inheritance.html), то непонятно, какой конкретно из типов иерархии [наследования](inheritance.html) является [мастером](master--association.html).

Представим, что мы имеем следующую ситуацию.

![](/images/pages/img/Учебник программиста Casseberry/primer2.jpg)

Класс `А` имеет мастера `М`, от которого имеется, как минимум, два наследника: `M1` и `M2`.

Соответственно, если имеется [объект данных](fo_dataobject.html) `a` (экземпляр класса A), то его мастером может быть экземпляр любого из классов `M, M1, M2`.

Допустим, что мы сохранили [сервисом данных](fo_sql-data-service.html) объект `a` с мастером `m1`.

Проблема заключается в следующем: если теперь [сервис данных](fo_sql-data-service.html) читает объект `а`, как он «узнает», что мастер принадлежит классу `M1` и, соответственно, находится в соответствующей ему структуре данных (для [Хранение-объектных-данных-в-реляционнои-базе-данных|реляционного хранения] — в какой таблице)? Ведь ему известен только тип `M`, но принципиально никак невозможно узнать, какие типы [унаследованы](inheritance.html) от `M`.


# Атрибута TypeUsage и PropertyTypeUsage
Для разрешения проблемы можно использовать специальные метаданные, позволяющие указать, что свойство `M` (ссылка на мастеровой класс) в классе данных `A`, в данном конкретном (сугубо прикладном) случае, может принимать не только значения типа `M`, а ещё и `M1`, и `M2`. В этом примере типы `M1` и `M2` называются '''используемыми типами'''.

Используемые типы указываются:

1. Атрибутом `TypeUsage` для [мастерового](master--association.html)/[детейлового](fo_detail-associations-and-their-properties.html) свойств класса данных, либо для класса-массива детейловых объектов (производного от `DetailArray`).


```
public class A:DataObject
{
	private M fM;
	
	[TypeUsage(new Type[]{typeof(M1), typeof(M2)})]
	public virtual M M {get{return fM;}set{fM=value;}}
}

public class M:DataObject
{
}

public class M1:M
{
}

public class M2:M
{
}
```

2.	Атрибутом `PropertyTypeUsage` для класса данных, чьему свойству необходимо указать используемые типы. Атрибут аналогичен, просто к классу бывает писать нагляднее, чем к конкретному свойству, тем более, когда их много. Кроме того, такая запись используется при необходимости изменить `TypeUsage` в унаследованном классе, без перегрузки свойства. Пример записи `PropertyTypeUsage`, эквивалентный `TypeUsage` в предыдущем примере:
```

[PropertyTypeUsage("M",new Type[]{typeof(M1), typeof(M2)})]
public class A:DataObject
{
	private M fM;		
	public virtual M M {get{return fM;}set{fM=value;}}
}
```

Метод `[Information](fo_information-class-as-metadata-supervisor.html).CheckUsingType` позволяет проверить внутри свойства, метода, откуда вызван, совместим ли тип с объявленным, согласно используемых типов.

# TypeUsageProvider.TypeUsage
Указанием дополнительных атрибутов невозможно полностью решить проблему используемых типов, поскольку может возникать ситуация вида:
![](/images/pages/img/Учебник программиста Casseberry/primer3.jpg)

Здесь класс-предок находится в отдельной сборке, поэтому `TypeUsage` прописать не удастся, так как в первой сборке необходимо знать типы `M1` и `M2` (находящиеся во второй сборке, ссылающейся на первую), а взаимные ссылки сборок друг на друга согласно `.Net` — невозможны. Дело может осложняться и тем, что разработчик, создающий сборку 2, в принципе не имеет доступа к исходному коду сборки 1 (соответственно, он не может объединить сборки в одну). Разумеется, `TypeUsage` прописывают и в этом случае, однако пользуются при этом статическим свойством статического класса `TypeUsageProvider.TypeUsage`. Здесь содержится разнообразная функциональность по управлению используемыми типами: можно прописывать используемые типы, узнавать/изменять их состав и т.п.

По мастеровым связям используемые типы можно указать для мастеров любой вложенности. Для этого необходимо указывать имена мастеровых свойств через точку. Методом `TypeUsageProvider.TypeUsage.GetCombinedTypeUsage` можно получить все типы в единой коллекции.

